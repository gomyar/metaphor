
Shortlist:
 - bug: deleting intermediate collections does not propagate to calcs
 - bug: schema.load_schema() does not enforce ordering of related calcs (and cannot load properly)
 - bug: ordering of calcs within resource not being updated on creation

 - need to be able to trace / debug calcs as a user

 - deleting grant or groups also removes reference from _grants list for all applicble resources
 - pagination - done
 - expand / fields params - done
 - collection functions
 - updates as idempotent commands
 - schema import / export
 - schema mutations
 - schema multiple versions, mutations in between
 - estimate effects of a given change (POST/PATCH/DELETE or schema change)
 - groups to schema, users to runtime
 - datetime
   - now() years() months() dates() hours() minutes() seconds() milliseconds() timedelta functions
 - integrations - all retrieved data is cached as proper resources
   - realtime w/ mongo / mysql
   - background thread/poll
   - webhooks

 - bug: deleting a spec field doesn't delete associated link_ field
 - bug: validate types for functions 
 - edit calc 
 - edit field
 - add helper functions
 - add mechanism for easily adding functions 
   - as aggregations
   - as python functions
 implement switch():
   - switch(resource_ref, case, case, case, ...)

 - ok, on second thoughts, maybe the grant "url" field should be a lrparse filter instead (companies.employees.ID123123123)


todo:
 - unique fields (user username)

 - gonna need brackets in the Conditions at some point ( A | ( B & C ) )

 - bug: delete does not update calcs correctly - attempt delete of grant after it's been created - cached grant still exists in user - done
 - bug: delete must cascade - done
   - this should fix problem deleting parent resources which contain child resources which are used in a calc (group/grant)

 - q: do links in colections need their own url (for deleting from collection)?
   - "link": /users/ID123/groups/ID456

 - bug: calcs which evaluate to a single link id throw an error - done

 - restrict allowed field names - done
 - proper http error codes (400 404 etc) - done
 - delete spec field, update all resources
  - throw error if field used in calc
 - rename field - maybe - would also have to update any calcs using the field

 - update entry in resource (updateid, timestamp etc)
   - sync updates across cluster using redis

 - adding invalid calc field raises exception - done
 - adding calc field with cyclic dependency raises error

 - cascading delete - done


Updates:
 - it doesn't matter if two updates are run on a resource at once, as long as the internal fields are kept consistent


Extra calcs:
 - order(collection, field, field, ...)
 - first(collection)
 - last(collection)
 - now()

Extra fields:
 - idstring: a string field that can be used as an id - lower case letters and underscores only
 - uniqueid: same as idstring, but must be unique
   - can also be used as a url identifier
 - date field
   - include simple calcs (now() + '1d') - could interpret a str as a delta
 - password field - ostensibly for use with users, but can be used for other resource maybe


Permissioning:
 - Users
   - get a /ego endpoint - done
   - contain group memberships
 - Groups
   - Resource collection fields also contain a list of groups which can read
     - And a separate collection for groups which can create
   - A single Resource has a list of groups for edit
   - Requests are filtered by the list of read groups in a collection
   - Posts are allowed based on the list of post groups in a collection
   - Put requests are allowed base on the list of put groups in a collection

 A user is a member of a group
 A group may have read / write / update / delete permissions on a resource
 A resources permissions are inherited by its direct children by default
 A user may create a link if they have write access on the source resource and read on the target
 A user may read / expand a link if they have read access on the source and target


Add "plot access" graph:
  - visualize the resources a user / group has access to in terms of the schema


/api/auth/(session|oauth2|...)
/api/ego
/api/users
/api/groups

/api/[root collection(s)]


Pagination
 - do this


Expand by get param:
 - aggregate calls on all GET requests, which optional expand - done
 - expand through links honours the permissions (groups) of the linked resource
 - add nested expand (yes, definitely)
 - optional: add offset / limit


Nested fields
 - handy for smaller, reused resources (Point, currency, x, y etc)
 - dot notation within calcs
 - may be possible to cheat and create long structured field names (i.e. point__x, point__y etc)


Move resource:
 - patch against _parent_id and _parent_field
 - works for links and collections


Pull link collections out to link table (maybe)


Nested Resources (based on existing resource spec)
 - not doing this, would make aggregates unworkable, staying with resources in own mongo collections for now

Nested Collections (ordered, based on existing resource spec)
 - not doing this either

OR Possibly specify complex field types BUT not as easy to move to own collection afterwards


Small todos:
 - bugs:
   - if an error occurs creating a field, the field is still added
 - js popups:
   - clear popup before "create" or "new" 
   - allow pressing Enter key to submit
 - schema editor
   - add delete for fields
   - add delete for resources
     - possibly need some sort of versioning warning
     - possibly add "deprecated" bool to fields / resources
   - filter own spec from "add field" -> "collection" type dropdown
   - add date field type
   - add new calc functions:
     - now()
   - add < and > and = as operators (like + or -) which resolve to boolean values (not just used in filter expressions)

   - need to be able to experimentally create schemas without applying them immediately
     - an edited schema could be called a "patch" on a given schema "version" 
       - could highlight mutators required to apply patch

 - calcs
   - add 

 - add orderedlist type (possibly ordered link list)
   - complicated, may involve linked list impl with $graphLookup aggregation
   - pay attention to atomic changes to items in the list, whether adding / deleting / reordering
     - maybe "PATCH" with _order field? for reordering call


Update algorithm:

 - create updater for each update spawned by a request (single field update or single object creation/deletion)
   - also for calc updates which may affect multiple objects
   - fields: update_id, spec_name field_name, running_at
 - run updater: aggregate calc dependencies, retrieve cursor to resource ids
 - iterate each resource:
 - for each resource, atomically read fields and mark as "being updated by"-> this update_id
   - if "being_updated_by" field is not null, then back off
 - calculate result:
 - attempt save:
   - if "being_updated_by" has changed, back off 


basic REST:
 - GET by url:
   - nested resource (collection/id/resource.field)
   - aggregated resources (collection/resources   &&   collection/resources/fields) - use calc parser
   - canonical url "self: http://collection/ID"
   - expansion of resources "expand=employee.section.category"
   - field filters
   - ordering
   - pagination
 - POST / PUT
   - create resource (collection/   {'name': 'etc'}
   - dependent updates scheduled (for calcs)
 - PATCH / DELETE
   - update resource (collection/ID
   - dependent updates scheduled (for calcs)


schema:
 - resource specs creation / edit
 - resource:
   - basic fields: str int float bool
   - calc fields:
     - basic calc types: str int float bool
     - collections of resources (cached by id)
   - link fields:
     - link to other resource (many to one)
   - collection fields:
     - parent relationship with target resource (one to one)
     - reverse linked through "parent_resource_field" field name (will return single parent resource)
   - linkcollection fields:
     - link relationship with target resource (many to one)
     - reverse linked through "link_resource_field" field name (will return list of linked resources)


calc fields:
 - parsed from "self" or "root" - aggregates 


updates
 - on POST / PATCH / DELETE / PUT
   - single / distributed update
 - atomic-ish recoverable idempotent updates
 - update request may wait on result of update, or leave running in background
 - some calc types may specific to be run in background
 - ability to attach to ongoing updates, get notifications of running updates


permissions:
 - root driven permissions
 - a user has access through a group - groups are assigned permissions to resources and all children
   - linked resources are not included - the canonical parent for a linked resource will need to be permissioned independently
 - permissions do not apply to or affect calcs
 - open question: should group permissions be applied to the schema? if so how do group changes affect schema versioning?


mutating the schema:
 - schemas are versions by uuid - major.minor.micro
   - breaking changes alter the major+minor+micro uuid
   - additive changes alter the minor+micro uuid
   - calc changes alter the micro uuid
 - should be possible to apply any change to a schema, and to alert for data deletion on a major change

 - may mark each resource by the hash of the schema used to create / last update it. On load, if the has is different from the current schema, reload the schema
 - might also have to mutate the just-loaded resource on demand

 - mutations:
   - add field (minor if defaulted or nullable, major if field is required)
   - add resource (minor)
   - update calc (minor if return type does not change / major if the return type changes?)
   - delete field (major)
   - delete resource(major)


export / import schema:
 - import updates the schema
   - checks update against existing schema, reports potential changes (and resource/field deletions)


 - enter calculated fields
   - string / int
   - collection (collection filters / functions that return a collection)
   - resource link (min max median - functions that take a collection and return 1 result)

add recalc worker
 - field dependencies
 - queue updates, no recalc clashes
  - global topsorted recalc queue?
  - idempotency may make this unnecessary


add basic schema
 - view schema
 - create schema through api
 - save schema in mongo

collect dependencies for schema / live

differentiate between embedded resources and linked resources on create
 - make atomic by forcing a second post call for linked resources or
 - embed the document in mongo document

validate input (correct / default fields)
alter resource atomically, then perform update, currently altering one field, updating, then another

updating too much for a single change

other stuff:
 - enum type (raises error if incorrect values used in calc or filter)
   - ie type=['dog','cat'] /animals?type='goose' raises exception


architecture
 - schema written to DB and propagted from another DB (greater version only applies if it passes checks)
 - separate DBs for different customers (linked using DB references)
 - security enforced through keys for each individual DB

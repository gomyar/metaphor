


Update algorithmL

 - create updater for each update spawned by a request (single field update or single object creation/deletion)
   - also for calc updates which may affect multiple objects
   - fields: update_id, spec_name field_name, running_at
 - run updater: aggregate calc dependencies, retrieve cursor to resource ids
 - iterate each resource:
 - for each resource, atomically read fields and mark as "being updated by"-> this update_id
   - if "being_updated_by" field is not null, then back off
 - calculate result:
 - attempt save:
   - if "being_updated_by" has changed, back off 



basic REST:
 - GET by url:
   - nested resource (collection/id/resource.field)
   - aggregated resources (collection/resources   &&   collection/resources/fields) - use calc parser
   - canonical url "self: http://collection/ID"
   - expansion of resources "expand=employee.section.category"
   - field filters
   - ordering
   - pagination
 - POST / PUT
   - create resource (collection/   {'name': 'etc'}
   - dependent updates scheduled (for calcs)
 - PATCH / DELETE
   - update resource (collection/ID
   - dependent updates scheduled (for calcs)


schema:
 - resource specs creation / edit
 - resource:
   - basic fields: str int float bool
   - calc fields:
     - basic calc types: str int float bool
     - collections of resources (cached by id)
   - link fields:
     - link to other resource (many to one)
   - collection fields:
     - parent relationship with target resource (one to one)
     - reverse linked through "parent_resource_field" field name (will return single parent resource)
   - linkcollection fields:
     - link relationship with target resource (many to one)
     - reverse linked through "link_resource_field" field name (will return list of linked resources)


calc fields:
 - parsed from "self" or "root" - aggregates 


updates
 - on POST / PATCH / DELETE / PUT
   - single / distributed update
 - atomic-ish recoverable idempotent updates
 - update request may wait on result of update, or leave running in background
 - some calc types may specific to be run in background
 - ability to attach to ongoing updates, get notifications of running updates


permissions:
 - root driven permissions
 - a user has access through a group - groups are assigned permissions to resources and all children
   - linked resources are not included - the canonical parent for a linked resource will need to be permissioned independently
 - permissions do not apply to or affect calcs


mutating the schema:
 - schemas are versions by uuid - major.minor.micro
   - breaking changes alter the major+minor+micro uuid
   - additive changes alter the minor+micro uuid
   - calc changes alter the micro uuid
 - should be possible to apply any change to a schema, and to alert for data deletion on a major change

 - may mark each resource by the hash of the schema used to create / last update it. On load, if the has is different from the current schema, reload the schema
 - might also have to mutate the just-loaded resource on demand
